# 25장. 클래스

# [javascript] ☕ 모던 자바스크립트

---

## 25장. 클래스

### 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 클래스는 함수다
- 클래스와 생성자 함수는 비슷하게 동작하지만 몇 가지 차이가 존재한다
    - 클래스는 new 연산자 없이 호출하면 에러가 발생
    - 클래스는 상속을 명시적으로 지원할 수 있도록 `extends` 와 `super` 키워드를 제공
    - 클래스는 호이스팅이 발생하지 않는 것 처럼 동작함
    - 클래스 내에 선언된 코드는 암묵적으로 strict mode 가 적용
    - 클래스의 constructor, 프로토타입 메서드, 정적 메서드 모두 `[[Enumerable]]` 값이 false 이다
- 클래스가 함수를 기반으로 하긴 하지만, 결국 생성자 함수와는 다른 새 객체 생성 메커니즘 으로 보는 것이 더 합당하다

### 25.2 클래스 정의

- 클래스는 일급객체이다
- 클래스에서 정의할 수 있는 메서드들
    - 생성자 함수
        - 클래스 이름이 아닌, `constructor(arg?)` 로 선언하면 된다
    - 정적 메서드
        - `static` 키워드를 붙이고 메서드를 선언하면 정적 메서드가 된다
    - 프로토타입 메서드
        - 키워드를 붙이지 않을 경우 프로토타입 메서드가 된다

### 25.3 클래스 호이스팅

- 클래스도 소스코드 평가 과정 단계에서 평가되어 함수 객체를 생성한다
    - 이 때 생성되는 함수 객체는 `constructor` 이다
    - 생성자와 프로토타입은 별개로 존재할 수 없기 때문에, 프로토타입도 더불어 생성된다
    - 대신, 클래스는 클래스 정의 이전에 참조할 수 없다
        - `let`, `const` 와 비슷하다

### 25.4 인스턴스 생성

- 클래스는 `new`  없이 호출할 경우 타입 에러가 발생한다
- 변수에 클래스를 넣어도 된다
    - e.g. `const me = class Person {};`

### 25.5 메서드

- 인스턴스 프로퍼티는 반드시 `constructor` 내부에서 선언되어야 했지만, 클래스 몸체에 프로퍼티를 선언할 수 있는 방식이 제안 되어 이미 모던 브라우저에서는 가능하다고 한다
- 클래스도 함수 객체의 고유의 프로퍼티를 모두 갖고 있다
    - arguments, caller, prototype…
- 클래스에서 정의하는 `constructor` 는 단순한 메서드가 아닌 클래스의 일부가 된다
- 클래스의 `constructor` 와 프로토타입의 `constructor` 는 연관이 없다
    - 클리스의 `constructor` 는 생성자 함수와 역할이 비슷하다
    - 프로토타입의 `constructor` 는 자신을 생성한 함수의 정보를 가리킨다
- 자바스크립트는 메서드 오버로드가 안되기 때문에, `constructor` 도 오버로드가 안된다
    - 생성자를 두 개 선언하면 예외가 발생한다
    - 생성자가 두 개가 되려면 `constructor` 내에서 분기 처리되어야 할 것 같다
- `constructor` 는 명시적으로 선언하지 않아도 빈 생성자가 암묵적으로 정의된다
- `constructor` 내에서 return 을 사용할 수 있다
    - 단, return 된 객체를 기준으로 인스턴스가 생성되니 주의해야 한다
    - 생성자 함수와 비슷하다
- 클래스 내에서 정의하는 메서드는 기본적으로 프로토타입 메서드로 정의된다
- 정적 메서드를 만드려면 `static` 키우드를 붙인다
- 역시나 프로토타입 메서드와 정적 메서드가 가리키는 `this` 는 다르다!
    - 프로토타입 메서드는 인스턴스를
    - 정적 메서드는 클래스 그 자체를 가리킨다
- 클래스 내에서 정의한 메서드는 non-constructor 이다

### 25.6 클래스의 인스턴스 생성 과정

1. 인스턴스 생성과 `this` 바인딩
    - `new` 와 함께 클래스를 호출하면 먼저 빈 객체가 생성되는데, 이게 미래의 인스턴스가 된다고 한다
    - 이렇게 생성된 인스턴스가 `this` 에 바인딩 된다
2. 인스턴스 초기화
    - `constructor` 내부 코드가 실행된다
    - 프로퍼티를 추가하거나 초기값을 통해 프로퍼티 값을 초기화한다
3. 인스턴스 반환
    - `this` 가 반환된다

### 25.7 프로퍼티

- 인스턴스의 프로퍼티는 `constructor` 내부에서 정의해야한다
    - 이 프로퍼티는 기본적으로 `public` 이라고 한다
- 접근자 프로퍼티도 선언할 수 있다
    - getter/setter
    - 접근자 프로퍼티는 메서드 형태이기 때문에 값을 가지지 않는다
- 자바스크립트는 인스턴스의 프로퍼티를 참조하려면 꼭 `this` 를 붙여야 한다!
- Node12, Chrome72 이상부터 클래스 필드를 선언할 수 있게 되었다
    - 그 전엔 문법 에러가 발생했다
    - 다만, 클래스 필드는 아직까지 ECMAScript 의 표준 사양은 아니지만 이미 승급이 확실시 되기 때문에 미리 구현했다고 한다
    - [ES13(2022) 에서 정식으로 도입되었다](https://www.infoworld.com/article/3665748/8-new-javascript-features-to-start-using-today.html)
    - 요런 문법 형태에서 기본값을 할당하지 않으면 undefined 를 가지게 된다
- 모든 클래스 필드는 인스턴스 프로퍼티가 된다
    - 만약 클래스 필드에 함수를 할당하게 된다면 이는 프로토타입 메서드가 아닌 인스턴스 메서드가 된다고 한다
    - 클래스 필드엔 필드만 선언하장
- Node12, Chrome74 부터 private 필드가 가능해졌당
    - 필드 선두에 `#` 을 붙여주면 된다!
    - private 필드를 참조할 때에도 `#` 을 붙여주면 된당
    - 이 문법도 [ES13(2022) 에서 정식으로 도입되었다](https://morioh.com/p/65c984a8b798)
    - 클래스의 메서드에도 private 제한이 가능하당
- 이전에는 정적 메서드만 정의할 수 있었지만, 이제는 정적 필드도 정의 가능하다고 한다
    - 마찬가지로 ES13 에서 추가된 모양이다
        - 뭐가 많이 바꼈다
    - [static 생성자도 있는 모양이다](https://www.mwanmobile.com/the-latest-es13-javascript-features/)
        - 심지어 얘는 중복 선언이 가능하다

### 25.8 상속에 의한 클래스 확장

- 프로토타입과 상속을 별개의 개념으로 두는 듯 하다
- 생성자 함수는 상속 문법(extends, super) 이 제공되지 않는다고 한다
- 상속도 결국 프로토타입 체인을 이뤄나가는 과정인듯하다
    - 실제로 클래스 객체간, 클래스의 인스턴스간 프로토타입 체인이 형성되어 있다
- 동적 상속도 가능하다 😱
    - 조건식이 들어가두 되나보다

```jsx
function Base1() { }
class Base2 { }
let condition = true;

class Derived extends (condition ? Base1 : Base2) { }

const derived = new Derived;

console.log(derived instanceof Base1); // true
console.log(derived instanceof Base2); // false
```

- 서브클래스에서 슈퍼클래스에 대한 생성자 호출이 명시적으로 이루어지지 않을 경우 다음과 같은 코드가 암묵적으로 정의된다고 한다
    - `…args` 는 Rest 파라미터라는 것이라고 한다
    - 인수를 배열로 전달받는 문법이라고 한당

```jsx
class Derived extends Base {
  constructor(...args) {
    super(...args);
  }
}
```

- `super` 관련 얘기는 자바와 비슷하당
- `super` 키워드로 접근하면 슈퍼타입의 프로토타입에 접근한다
    - 즉, `super` 는 슈퍼타입의 프로토타입을 가리키기 때문에, 일반 함수 형태로 정의된 함수들은 참조할 수 없다
    - 이 말인 즉슨, 프로토타입 메서드는 내부슬롯 `[[HomeObject]]` 이라는 것을 가지고 있다는 것이당
        - `[[HomeObject]]` 는 메서드 자신을 바인딩하고 있는 객체를 가리킨다고 한다
            - 프로토타입 메서드라면 `[[HomeObject]]` 는 프로토타입을 가리키게 된다
            - 정적 메서드라면 `[[HomeObject]]` 는 해당 객체 그 자체를 가리키게 된다
    - 메서드 축약 표현으로 정의된 함수만 이 `[[HomeObject]]` 라는 내부슬롯을 가진다고 한다
    
    ```jsx
    const obj = {
      foo() { }, // contain [[HomeObject]]
      bar: function () { } // not contain [[HomeObject]]
    }
    ```
    
- 놀랍게도 `super` 키워드는 객체 리터럴에서도 사용할 수 있나보다
    - 프로토타입 체인만 형성 되어 있다면 괜찮은듯 하다
    - 슈퍼타입에 대한 탐색이 `[[HomeObject]]` 를 사용하는 메커니즘이다보니 객체 리터럴 형식에서도 가능한듯 하다
- 놀랍게도 정적인 속성들에게도 `super` 를 사용할 수 있다
    - 결국 `[[HomeObject]]` 의 탐색 메커니즘을 따르기 때문에, 굳이 프로토타입 대상으로만 국한되어 사용되지 않기 때문인듯 하다
    - 서브클래스의 정적 메서드에서 `super` 참조를 걸게 되면 슈퍼클래스의 정적 속성이 참조된당