# [javascript] ☕ 모던 자바스크립트

---

## 24. 클로저

- 딱히 자바스크립트만의 특성은 아니고 함수형 프로그래밍 언어에서 사용되는 특성임
- `함수가 선언된 렉시컬 환경` 이라는 키워드에 대한 이해만 있으면 어렵지 않다고 함

### 24.1 렉시컬 스코프

- 함수의 상위 스코프는 함수가 호출 될 때 결정되는 것이 아니라, 함수가 정의된 물리적인 위치 에 따라 결정됨
    - 이를 렉시컬 스코프, 혹은 정적 스코프라고 함

### 24.2 함수 객체의 내부 슬롯 `[[Environment]]`

- 함수 객체는 자신의 내부 슬롯 `[[Environment]]` 에 자신이 정의된 환경, 즉 자신의 상위 스코프의 참조를 저장함
    - 이는, 현재 실행 중인 실행 컨텍스트의 렉시컬 환경
    - 함수 객체를 생성하는 시점은 이미 상위 함수 혹은 전역 코드가 평가되거나 실행되고 있는 시점이고, 이 때 실행 중인 컨텍스트가 현재 실행 중인 실행 컨텍스트이기 때문..
- `[[Environment]]` 에 저장된 상위 스코프 참조는 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 ‘외부 렉시컬 환경에 대한 참조’ 에 저장될 참조 값이기도 함
- 실행 컨텍스트는 렉시컬 환경이라는 것을 포함할 수 있다
    - 렉시컬 환경에는 매개변수나… 내부에 정의된 식별자 등의 정보가 저장되어 있음
        - 특정 렉시컬 환경에 특정 식별자가 정의 되어 있다.. 라는 것을 스코프라고 봐도 되지 않을까
    - 실행 컨텍스트는 어디까지나 런타임인 것 같고, 중요한건 실행 컨텍스트가 참조하는 렉시컬 환경인듯
        - 렉시컬 환경을 참조하는 곳이 없어질 경우, 렉시컬 환경은 가비지 컬렉터가 수거한다
        - 실행 컨텍스트와 렉시컬 환경의 라이프사이클은 동일하지 않다
    - 그리고 이 렉시컬 환경에는 자신이 정의된 위치의 상위 렉시컬 환경의 참조(외부 렉시컬 환경에 대한 참조)를 저장함
    - 이를 통해 스코프 체인 검색이 이루어진다
        - 자신의 렉시컬 환경에 식별자 정보가 없다면, 렉시컬 환경의 속성 중 외부 렉시컬 환경에 대한 참조 내에 검색하려는 식별자가 존재하는지 검색

### 24.3 클로저와 렉시컬 환경

- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를  참조할 수 있다. 이러한 중첩 함수를 `클로저(closure)` 라고 부른다.
    
    ```jsx
    const x = 1;
    
    function outer() {
      const x = 10;
      const inner = function () {
    		// 이 구문이 정의될 때, const x 는 상위 스코프에서 이미 정의 되어 있으며, 값은 10 으로 할당 되어 있음
    		// 렉시컬 스코프 정책을 통해 해당 메서드는 어디에서 호출하던 상관 없이 10 이라는 값을 참조하게 됨
        console.log(x); 
      };
    
    	// inner 함수를 반환함으로써 outer 함수의 생명주기는 종료된다
      return inner;
    }
    
    const innerFunc = outer();
    
    // 해당 코드의 실행 결과는 렉시컬 스코프 정책에 따라 10 이 출력된다
    innerFunc(); 
    ```
    
- 자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저다
    - 하지만 일반적으로 모든 함수를 클로저라고 하지는 않음
    - 만약, 중첩 함수 구조에서 상위 스코프의 어떠한 식별자도 참조하지 않는 함수라면 이는 클로저가 아니다
    
    ```jsx
    function outer() {
      const x = 10;
      const inner = function () {
        const x = 11;
    		// 이 경우 console.log 가 참조하는 x 는 inner.x 이다
    		// 상위 스코프를 참조하지 않기 때문에 inner 는 클로저가 아니다
    		// 이런 함수의 경우, 대부분의 모던 브라우저에서는 상위 스코프를 기억하지 않게 한다고 한다
    		// 참조하지 않는 경우에도 메모리를 점유하고 있는 것은 낭비이기 때문에..
        console.log(x);
      };
    
      return inner;
    }
    ```
    
- 클로저의 핵심은 중첩 함수 구조에서 내부 함수가 외부 함수의 식별자를 참조하게 되어 외부 함수보다 내부 함수의 라이프 사이클이 더 긴 경우를 한정하여 지칭한다
- 클로저가 참조하는 상위 스코프의 변수를 `자유 변수(Free variable)` 라고 한다

### 24.4 클로저의 활용

- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다
    - `return {…}` 도 클로저인듯?
- 클로저는 상태를 은닉하며 특정 함수에게만 상태 변경을 허용하기 위해 사용한다고 한다

```jsx
/*
1. 즉시 실행 함수가 수행되며 새 렉시컬 환경을 생성한다 
2. 렉시컬 환경에 num 을 저장한다
3. 이후 즉시 실행 함수의 생명주기가 종료되면서 ++num 을 수행하는 함수 객체가 반환된다
4. 즉시 실행 함수가 함수 객체를 리턴함으로써 increses 에는 리턴한 함수 객체가 할당되며, 이는 클로저이다
5. 즉, increses 에는 상위 스코프의 렉시컬 환경이 저장된 클로저가 할당된다
6. increses 를 호출하면 클로저가 호출된다
7. 클로저를 호출할 때 마다 스코프 체인 검색을 통해 클로저의 외부 렉시컬 환경에 저장된 num 을 참조하게 된다 
8. increses 를 호출하며 비로소 연속적으로 num 증가 연산을 수행할 수 있게 된다 
 */

// 즉시 실행 함수는 한 번만 호출된다
const increase = (function () {
  let num = 0;

	// 클로저
  return function () {
    return ++num;
  }
}());

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- return 시 선언하는 객체 리터럴은 별도의 스코프를 만들지 않는다구 한다
    - 단, return 안의 객체 리터럴에 함수가 정의되어 있다면 이는 클로저가 될 수 있는 것이다
- 은닉된 프로퍼티를 구현하려면.. 즉시 실행 함수로 래핑하여 클로저로 public interface 를 뚫어주는 방식으로… 응용할 수 있겠다
    - 프로퍼티에게 접근할 수 있는 유일한 경로가 클로저이므로, 외부에선 직접 접근할 수 없게 되어버린다
    - 이런 특징 때문에 클로저는 함수형 패러다임에서 추구하는 완벽한 함수를 구현하기 위한 최적의 구현 방법이다
- 콜백 패턴에서도 상태 조작을 다른 함수에게 위임할 때 클로저가 아주 유용하게 사용된다
    
    ```jsx
    // Counter 를 만드는 고차 함수
    // 매개변수 aux 는 콜백으로 실행할 함수 객체
    function makeCounter(aux) {
    	// 카운트 상태를 유지하기 위한 자유 변수
      let counter = 0;
    
      return function () {
    		// 인수로 전달받은 보조 함수에게 상태 변경을 위임함
    		// increaser 의 경우 counter 변수에 increase(0) 을 재할당하여 increase(0) 을 반환
        counter = aux(counter);
    
        return counter;
      }
    }
    
    // 보조 함수
    function increase(n) {
      return ++n;
    }
    
    // 보조 함수
    function decrease(n) {
      return --n;
    }
    
    // increaser 에 저장된 함수 객체는 makeCounter 가 반환한 클로저
    // 이 클로저는 increase(n) 를 수행
    // 클로저가 반환될 때 마다 각자의 독립된 렉시컬 환경을 갖게 됨
    const increaser = makeCounter(increase);
    console.log(increaser()); // 1
    console.log(increaser()); // 2
    
    // decreaser 에 저장된 함수 객체는 makeCounter 가 반환한 클로저
    // 이 클로저는 increaser 와 별개의 스코프를 가지고 있음
    // 자유 변수 초기 값인 0부터 decrease(n) 수행
    const decreaser = makeCounter(decrease);
    console.log(decreaser()); // -1
    console.log(decreaser()); // -2
    ```
    
- 만약, 상태를 공유하는 형태로 클로저를 활용하려면 즉시 실행 함수를 활용한 고차 함수를 만들어 보조 함수를 전달하면 된다,,
    
    ```jsx
    const counter = (function () {
      let counter = 0;
    
      return function (aux) {
        counter = aux(counter);
    
        return counter;
      }
    }());
    
    // 보조 함수
    function increase(n) {
      return ++n;
    }
    
    // 보조 함수
    function decrease(n) {
      return --n;
    }
    
    console.log(counter(increase)); // 1
    console.log(counter(increase)); // 2
    console.log(counter(decrease)); // 1
    console.log(counter(decrease)); // 0
    ```
    

### 24.5 캡슐화와 정보 은닉

- `캡슐화` 란… 객체의 프로퍼티와 프로퍼티를 조작하는 메서드를 하나로 묶는 것
- 뿐만 아니라 특정 프로퍼티나 메서드를 감추는 목적으로도 사용하는데, 이를 `정보 은닉` 이라고 함
- 정보 은닉은 굳이 외부에 공개하지 않아도 되는 내용들을 감추게 되어, 의도치 않은 접근을 막을 수 있음
    - `결합도` 측면에서, 정보 은닉은 매우 중요하다
- 자바스크립트의 객체의 프로퍼티와 메서드는 기본적으로는 public 이다
    - 접근 제한자가 없기 때문
- 즉시 실행 함수와 클로저만으로 클래스 기반 객체지향 언어의 `private` 를 완벽하게 구현하기는 어려웠으나… 최신 문법에서는 class 에서 private 을 지원한다고 한다

### 24.6 자주 발생하는 실수

```jsx
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}

for (var j = 0; j < funcs.length; j++) {
	// 놀랍게도 3 이 세 번 찍힌다
	// var i 가 전역 변수이기 때문에... for 의 증감 연산으로 3 까지 올라간 i 는 참조할 때에도 그대로 3으로 반환된다
  console.log(funcs[j]());
}
```

- 위 코드의 경우 `funcs` 배열에 클로저 함수를 추가하면 되지만, 그냥 for 의 변수 선언문을 `var` 대신 `let` 으로 선언하면 된다 ^^

```jsx
const funcs = [];

// let 은 블록 레벨 스코프를 지원한다
for (let i = 0; i < 3; i++) {
	// 반복문이 수행될 때마다 새 함수 객체가 할당된다
  funcs[i] = function () {
		// 새 함수 객체가 생성될 때 마다 각 함수 별 렉시컬 환경이 생성된다
		// 각 렉시컬 환경마다 각각의 레코드를 가지고 있으며, 이 레코드에 i 가 추가된다
		// 이 동작은 마치 스냅샷을 찍는 것 처럼 반복된다
    return i;
  };
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```