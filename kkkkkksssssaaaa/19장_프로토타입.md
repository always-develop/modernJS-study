# 19장. 프로토타입

# [javascript] ☕ 모던 자바스크립트

---

## 19장. 프로토타입

- ES6 에서 클래스가 추가되었는데 사실 얘도 함수라고 한다
- 클래스와 생성자 함수 모두 프로토타입 기반 인스턴스를 생성하지만 동일하게 동작하지 않음
    - 클래스가 생성자 함수보다 더 엄격함
    - 생성자 함수에서 제공하지 않는 기능들도 제공
- 클래스를 단순하게 문법적 설탕(Syntax Sugar) 로 보는 것 보다는 새로운 객체 생성 매커니즘으로 보는 것이 합당

### 19.1 객체지향 프로그래밍

- 객체지향 프로그래밍이란, 프로그램을 여러 개의 독립적인 단위(객체)들의 집합이라는 관점으로 바라보는 프로그래밍 패러다임
- 객체지향 프로그래밍은 실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작
- `추상화(abstraction)` 란, 다양한 속성 중 프로그램에 필요한 속성만 간추려 내어 표현하는 것
    - 불필요하거나 세부 구현을 숨긴다, 라는 의미로도 사용됨
- 객체는 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
    - 객체는 객체의 `상태` 를 나타내는 데이터와 상태를 조작할 수 있는 `동작` 으로 구성됨
- 객체는 다른 객체와 관계성(relationship) 을 가질 수 있음
    - 이는 객체지향의 용어로 표현하자면 다른 객체와 `협력` 할 수 있다고 함

### 19.2 상속과 프로토타입

- 자바스크립트에서 상속은 중복 코드를 해결하기 위한 수단으로 쓰이는 듯?
- 코드 재사용이라는 관점에서 매우 유용하다고 소개하고 있다

### 19.3 프로토타입 객체

- 프로토타입 객체(==프로토타입)는 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용됨
- 모든 객체는 `[[Prototype]]` 내부 슬롯을 가짐
- 객체 리털로 생성된 객체의 프로토타입은 `Object.prototype` 이고 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 되어 있는 객체임
- 모든 객체는 하나의 프로토타입을 가짐
    - 하지만 프로토타입이 없을 수도 있다. `[[Prototype]]` 내부 슬롯이 null 인 경우 프로토타입이 없는 것이당
- 모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 프로토타입에 접근할 수 있음
    - 접근자 프로퍼티는 `value` 를 가지지 않는, getter 와 setter 로 이루어진 프로퍼티임
    - `__proto__` 는 getter / setter 함수를 통해 자신의 프로토타입에 접근함
        - 즉, 새로운 프로토타입도 할당이 가능함… 😱
    - 이 접근자 프로퍼티는 Object.prototype 의 프로퍼티이므로 모든 객체는 `Object.prototype` 을 상속받음
    
    ```jsx
    const person = {
      name: 'Lee'
    };
    
    /*
    person 객체 자체에서 __proto__ 프로퍼티를 가지고 있지 않기 때문에 false 출력
     */
    console.log(person.hasOwnProperty('__proto__'));
    
    /*
    {
      get: [Function: get __proto__],
      set: [Function: set __proto__],
      enumerable: false,
      configurable: true
    } 
    
    Object.property 는 접근자 프로퍼티이기 때문에 getter, setter 가 정의되어 있음
     */
    console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
    
    /*
    객체 리터럴로 선언한 객체는 Object.prototype 을 상속 받기 때문에, 두 객체의 프로토타입은 동등하다
     */
    console.log({}.__proto__ === Object.prototype);
    ```
    
- 스코프도 그러하듯 프로토타입도 체인 형태로 연결 되어 있음
    - 프로토타입 체인의 최상위에는 Object.prototype 이 존재
- 상호 참조에 의한 프로토타입 체인이 생성될 경우 TypeError 를 던진다
    - 무분별한 프로토타입 교체로 인한 상호 참조 현상을 방지하기 위해 프로토타입은 setter 메서드를 통해 프로토타입을 교체한다고 한다
- 프로토타입 체인도 단방향 연결 리스트로 구현되어 있다
    - 검색 방향이 한 방향으로만 흘러간다는 뜻
- `__proto__` 는 ES6 에서 표준화 되었다
    - 이전까지는 비표준이었다
    - 코드 내에서 `__proto__` 를 직접 사용하는 것은 권장하지 않는다고 한다..
    - Object 빌트인 객체에 있는 `getPrototypeOf()` 메서드를 사용해서 접근하는걸 권장한다
- 함수 객체는 `prototype` 이라는 프로퍼티를 직접 가질 수 있음
    - 이는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴
        - 그리고 해당 인스턴스의 프로토타입은.. Object.prototype 을 상속받는다
    - 단, 생성자 함수로 사용되지 않는 형태의 함수들(e.g. 화살표 함수)는 프로토타입을 직접 가지지 않음
- 모든 객체가 가지고 있는(==Object.prototype 에게 상속받은) `__proto__` 접근자 프로퍼티와 함수 객체만 가지고 있는 `prototype` 프로퍼티는 결국 동일한 프로토타입을 가리킴..!
    - 함수 객체의 `prototype` 프로퍼티는 생성자 함수가 자신이 생성할 인스턴스에게 프로토타입을 할당하기 위해 사용함
- 생성자 함수로 생성한 인스턴스의 `constructor` 와 생성자 함수 자체는 동일하다

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

console.log(me.constructor == Person); // true
```

### 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 리터럴 표기법에 의해 생성된 객체는 프로토타입의 `constructor` 프로퍼티가 가리키는 행성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수 없다
- Object 의 생성자 함수에 인수를 전달하지 않거나 undefined, null 같은걸 넣으면 `Object.prototype` 을 프로토타입으로 가지는 빈 객체를 생성한다고 한다
    
    ```jsx
    const emptyObj = new Object();
    const empty = {};
    
    /**
     * 두 객체 모두 [Object: null prototype] {} 를 반환
     */
    console.log(emptyObj.__proto__, empty.__proto__);
    
    /**
     * 두 객체의 프로토타입은 동일하다
     */
    console.log(emptyObj.__proto__ === empty.__proto__);
    ```
    
    - 같은 프로토타입을 반환한다고 하더라도, `new Object()` 와 `{}` 의 내부 동작 방식까지 동일한 것은 아님
    - 즉, 다른 행위를 통해 같은 객체를 반환하는 것….!
- 리터럴 표기법으로 선언한 함수는 Function 의 생성자를 통해 생성된 것으로 표기된다
    
    ```jsx
    function foo() { };
    
    console.log(foo.constructor === Function); // true
    ```
    
    - 프로토타입은 생성자 함수와 더불어 생성된다
    - 프로토타입과 생성자 함수는 단독으로 존재할 수 없다
    - 즉, 리터럴 표기법에 의해 생성된 객체도 생성자 함수에 의해 생성된 객체들과 본질적으로 큰 차이가 없다

### 19.5 프로토타입의 생성 시점

- 객체는 리터럴 표기법이나 생성자 함수에 의해 생성된다
    - 결국 모든 객체는 생성자 함수와 연결되어 있음
- 함수도 호이스팅 되기 때문에, 프로토타입도 호이스팅되는 그 시점에 생성된다
    - 이 때 생성된 프로토타입은 `constructor` 프로퍼티만 갖는 객체라고 함
        - 사용자 정의 생성자 함수의 경우, 이 시점에서는 언제나 `Object.prototype` 을 갖게 된다
    - 이후, 생성자 함수가 실제로 호출되어 인스턴스가 생성될 때, 인스턴스의 `[[Prototype]]` 내부 슬롯에 호이스팅 되었던 프로토타입이 할당된다고 한당
- 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성되며 빌트인 생성자 함수 객체의 `prototype` 프로퍼티에 바인딩 됨
    - 사용자 정의 생성자 함수가 호이스팅 되는 것과 비슷한 메커니즘이다

### 19.6 객체 생성 방식과 프로토타입의 결정

- 객체는 추상 연산 `OrdinaryObjectCreate` 에 의해 생성된다
    - 추상 연산이란 내부 슬롯, 내부 메서드처럼 ECMAScript 에서 사용하는 내부 알고리즘을 뜻한다
    - 이 추상 연산은 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달받는다
        - 객체에 사용될 프로퍼티들도 받긴 한다
    - 추상 연산을 통해 우선 빈 객체를 생성하고, 인수로 전달받은 프로토타입 객체를 할당하고, 프로퍼티 목록이 존재한다면 프로퍼티를 추가하여 반환한다
    - 즉, 프로토타입 객체는 `OrdinaryObjectCreate` 에 어떤 프로토타입 인수가 전달되는지에 따라 결정되며, 이 인수는 객체 생성 방식에 의해 결정됨!
        - e.g. 객체 리터럴을 사용하여 객체를 생성하는 경우 `Object.prototype` 이 인수로 전달됨
- 프로토타입에 직접 프로퍼티를 추가하는 방법도 허용되나보다
    - 사용자 정의 생성자 함수는 기본적으로 `constructor` 프로퍼티와 `Object.prototype` 만 가지고 있기 때문인듯
    - 프로토타입에 메서드를 추가할 때에는 생성자 함수와 같이 즉시 실행 함수로 감싸서 사용하는게 좋겠당
    
    ```jsx
    const Person = (function () {
      function Person(name) {
        this.name = name;
      }
    
      Person.prototype.sayHello = function () {
        console.log(`Hi! my name is ${this.name}`);
      }
    
      return Person;
    }());
    
    const me = new Person('Lee');
    const you = new Person('Kim');
    
    me.sayHello();
    you.sayHello();
    
    console.log(me.constructor.prototype);
    ```
    

### 19.7 프로토타입 체인

- 사용자 정의 생성자 함수에 의해 생성된 인스턴스도 결국 `Object.prototype` 을 상속 받는다
- 프로토타입 체인과 스코프 체인은 비슷한 메커니즘으로 동작한다
    - 스코프 체인처럼, 특정 프로퍼티가 특정 객체에 존재하지 않을 경우 프로토타입을 따라 해당 프로퍼티를 찾아 올라간다
    - `Object` 에 정의된 `hasOwnProperty` 를, 명시적으로 `Object.prototype` 을 상속받지 않은 객체들이 사용할 수 있는 이유도 프로토타입이 체이닝 되어 있기 때문에 가능하다
    - 단, 프로토타입 체인의 종단까지 왔을 경우에도 프로퍼티를 찾지 못했다면 undefined 를 반환한다 😱
- 스코프 체인과 프로토타입 체인은 서로 다른 것이 아니라, 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용한다!

### 19.8 오버라이딩과 프로퍼티 섀도잉

- 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 한다
- 인스턴스 프로퍼티는 오버라이딩 가능하다 ^^;;
    - 동적으로 생성 가능한데다가 오버라이딩까지 된다고 하니 객체 불변성을 지키는데에 심혈을 기울여야할 것 같다.
- 자바스크립트는 오버로딩을 지원하지 않는다 😱
    - 함수의 시그니처가 식별자가 되는 것이 아니라, 함수의 `이름` 이 암묵적으로 식별자로 할당되어서 그런듯 하다
- 프로토타입에 접근하려면 인스턴스가 아닌, 인스턴스의 프로토타입에 직접 접근해야한다
    - `getOwnPropertyDescriptor` 가 프로토타입의 프로퍼티까지 탐색하지 않는 것도 같은 이유인가?

### 19.9 프로토타입의 교체

- 프로토타입은 동적으로 교체 가능하다
    - 미치겠네 ㅋㅋ
- 프로토타입을 교체도 가능하고, 프로토타입 자체도 변경 가능하다
    - 엔진이 만들어주는 `constructor` 프로퍼티도 없어질 수 있음 ㅋㅋㅋㅋㅋㅋㅋ
- 휴~ 프로토타입은 직접 교체하지 않는 것이 좋다고 한다
    - 상속을 구현할거면 차라리 ES6 에서 추가된 `class` 를 사용하는게 더 직관적이라고 한다

### 19.10 instanceof 연산자

- 자바스크립트는 타입이 없기 때문에.. 인스턴스와 생성자 함수간 비교에 사용한다
- 단, 이 연산자는 `프로토타입 체인에 포함되면` true 를 반환하니 주의
    - 객체와 Object 를 비교하면.. 항상 true 가 나올 것이다

### 19.11 직접 상속

- `Object.create` 를 통해 프로토타입을 명시적으로 지정하여 새로운 객체를 생성할 수 있다