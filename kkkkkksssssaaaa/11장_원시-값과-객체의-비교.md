# 11장. 원시 값과 객체의 비교

# [javascript] ☕ 모던 자바스크립트

---

## 11장. 원시 값과 객체의 비교

- 원시 값은 실제 값(원시 타입의 값)이 저장되고, 객체 값은 참조(포인터 주소)가 저장됨
    - e.g. 엑셀로 예를 들어 `A1=30`, `B2=A1` 이라면 A1 은 원시 값이고 B2 는 참조를 저장한 것..

### 11.1 원시 값

- 원시 값은 변경 불가능 하다
    - 더 정확히는 같은 주소의 메모리 공간에 저장된 값이 업데이트 되지 않는다
    - 변수가 업데이트 불가능하다는 것이 아니다!!
    - 이러한 특성을 `불변성(Immutability)` 이라고 한다
- string 도 원시 타입이기 때문에 불변성을 가진다
    - 자바도 마찬가지
- 문자열은 유사 배열 객체이기 때문에 인덱스로 문자에 접근할 수 있음
    - 인덱스로 접근하여 문자열의 일부만 변경하는 것은 허용되지 않으나, 별다른 에러가 발생하지 않음
    - 단, 완전한 재할당은 가능하니 웬만하면 저런 패턴은 쓰지 않는게 좋겠음
- pass-by-value 로 복사된 값은 완전 다른 메모리 공간에 할당된다
    - 같은 값을 바라보는게 아니다!
    - 단, 자바의 문자열(String) 은 동일한 가상머신 내에 같은 문자열이 존재한다면 해당 문자열을 재사용하는 특징이 있음
- 파이썬의 경우 복사된 값이 같은 상태면 같은 주소를 바라보고 값이 변경될 때 새 메모리 공간에 변경된 값이 할당된다고 한다

### 11.2 객체

- 객체는 말하자면 복합 자료구조이다
    - 원시 값처럼 크기가 미리 정해져있지 않다
    - 객체가 가지는 속성 개수의 제한도 없다
- 자바스크립트의 객체의 프로퍼티 키는 `해시테이블` 로 관리된다
    - 해시테이블이란 기본적으로 Key, Value 형태의 자료 구조
        - Key 값을 `해시 함수` 를 통해 배열의 인덱스 값으로 바꿔줌
        - 해당하는 인덱스에 Value 를 매핑해줌
        - 이 때 Value 의 배열을 `버킷` 이라고 함
        
        [https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeHiqbk%2FbtqS1WeoGXA%2FfIo6eAPnZtGiY9Glrn8Zek%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeHiqbk%2FbtqS1WeoGXA%2FfIo6eAPnZtGiY9Glrn8Zek%2Fimg.png)
        
    - [https://mangkyu.tistory.com/102](https://mangkyu.tistory.com/102)
- 자바스크립트에선 객체가 인스턴스화 되어도 프로퍼티와 메서드를 추가할 수 있다 😱
    - 하지마라
    - 비효율적이라고 하지 말란다 휴
    - 동적 탐색이란?
    - 히든 클래스란?
- 객체 타입은 변경이 가능하다…!
    - 같은 메모리 공간에서의 값이 업데이트가 가능하다는 뜻
    - 원시 값과 반대 😝
- 메모리를 효율적으로 사용하기 위해 객체 타입은 변경 가능하다
    - 객체 타입의 크기도 가늠할 수 없다는게 제일 큰 문제인듯 하다
- 얕은 복사 —> 단순하게 다른 변수가 같은 참조를 바라볼 뿐인 경우..
- 깊은 복사 —> 참조가 가지고 있는 원시 값 까지 모두 복사한 복사본을 만듬

```jsx
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o }; 
console.log(c1 === o); // false, o 와 c1 은 각기 다른 변수로서 다른 메모리 공간에 할당 되었기 때문에 false 반환
console.log(c1.x === o.x); // true, c1 은 o 가 참조하는 메모리 공간을 함께 참조하기 때문에 
													 // c1.x 와 o.x 는 완전히 같은 값

// 깊은 복사
const _ = require('lodash');
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false, o 와 c2 는 각기 다른 변수로서 다른 메모리 공간에 할당 되었기 때문에 false 반환
console.log(c2.x === o.x) // false, 깊은 복사를 통해 c2 는 o 의 모든 프로퍼티의 복사본을 만들어 
													// 다른 메모리에 할당했기 때문에 c2.x 와 o.x 는 다른 메모리 공간에 존재
```

- 참조에 의한 전달은 `얕은 복사` 를 수행한다