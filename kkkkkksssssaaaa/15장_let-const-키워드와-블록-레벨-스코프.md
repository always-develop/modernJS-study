# 15장. let, const 키워드와 블록 레벨 스코프

# [javascript] ☕ 모던 자바스크립트

---

## 15장. let, const 키워드와 블록 레벨 스코프

### 15.1 var 키워드로 선언한 변수의 문제점

- 중복 선언 가능
    - 무조건 나중에 선언된게 덮어 쓰는게 아니라, 초기화문이 없는 변수 선언은 무시된다
- 함수 레벨 스코프
    - 제어문(if, while…) 에서 선언한 변수는 제어문 바깥에서도 유효하게 동작한다
- 변수 호이스팅

### 15.2 let 키워드

- 중복 선언이 불가능하다
    - 당연함
- 블록 레벨 스코프
    - 제어문 안에서 선언한 변수는 제어문 내에서만 유효하다
- 호이스팅이 발생하지 않는 것처럼 동작한다
    - var 는 호이스팅 될 때 선언 단계와 초기화 단계가 한 번에 진행됨
        - 초기화 시 undefined 로 초기화
    - let 은 선언 단계와 초기화 단계가 분리되어 진행됨
        - 일단은 선언 단계는 실행된다
        - 단, var 와는 다르게 초기화 되지 않은 상태이므로 변수 선언보다 호출이 먼저 올 경우 ReferenceError 를 반환
        - 스코프의 시작 지점부터 변수의 초기화 시작 전 까지 변수를 참조할 수 없는 구간을 `일시적 사각 지대(Temporal Dead Zone:TDZ)` 라고 한다
    - 호이스팅 되지 않는 것 처럼 동작할 뿐이지, 사실은 호이스팅 되기 때문에 아래와 같은 결과가 나온다
    
    ```jsx
    let x = 10;
    
    (function() {
      console.log(x); // ReferenceError
    									// 블록 스코프가 시작될 때 해당 라인 아래에 작성된 변수 x 는 이미 선언됨
    									// 다만 undefined 로 기본값을 할당하지 않은 상태
      let x = 1;
    } ())
    ```
    
- 자바스크립트의 모든 선언문은 호이스팅 되나, let, const, class 는 단지 호이스팅이 발생하지 않은 것 처럼 동작함
    - 호이스팅 != 선언+초기화
    - 호이스팅은 코드를 아래에서 위로 끌어 올려서 실행하는 특징 그 자체를 뜻함!!

### 15.3 const 키워드

- const 는 선언과 동시에 초기화 되어야 한다
- const 에 담긴 변수는 재할당이 금지된다
    - 자바는 변수 앞에 `final` 키워드를 붙이면 재할당 불가인 객체로 선언 가능
    - 자바의 경우도 재할당 금지 변수는 선언과 동시에 초기화 되어야 함
    - e.g. `private final String name = “왕해삼”;`
- 자바스크립트의 원시값 불변 특징을 이용하여 const 를 상수로 활용하면 좋음
- const 상수를 선언할 때에 변수 명은 대문자 스네이크 케이스로 작성
    - 자바도 똑같
- const 객체는 변경 가능하다
    - 객체는 `재할당` 이라는 개념이 없다
    - 같은 메모리 공간에서 변경이 일어나기 때문
    - const 는 `재할당` 만 금지이기 때문에, 재할당을 하지 않고 값을 변경하는 객체 타입은 변경이 가능하다
    - 이는 자바도 마찬가지!!
        - 재할당을 하지 않고 변경 가능한 객체들은 여전히 가변 상태인 것이당

### 15.4 var vs. let vs. const

- ES6 부터는 var 사용 자제
- 재할당이 필요한 경우에는 let 을 사용하지만 이 때에는 스코프를 최대한 좁게 만들어야함
- 변수를 선언할 때에는 일단 const 로 만드는걸 추천한다
    - 이펙티브 자바에서도 재할당 금지 상태에서 뭔가 하는걸 추천하긴 했음