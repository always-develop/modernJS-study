# 23장. 실행 컨텍스트

# [javascript] ☕ 모던 자바스크립트

---

## 23장. 실행 컨텍스트

### 23.1 소스코드의 타입

- ECMAScript 사양은 소스코드를 네 가지 타입으로 구분한다
    - 전역 코드
        - 전역 스코프를 생성
        - 전역 코드가 평가될 때 전역 실행 컨텍스트가 생성
    - 함수 코드
        - 지역 스코프를 생성
        - 지역 변수, 매개 변수, arguments 객체 관리
        - 함수 코드가 평가될 때 함수 실행 컨텍스트가 생성
    - eval 코드
        - 엄격 모드에서는 자신만의 독자적 스코프를 생성함
    - 모듈 코드
        - 모듈별로 독립적인 모듈 스코프를 생성
- 네 가지 소스코드가 실행 컨텍스트를 생성
    - 즉, 자바스크립트의 실행 컨텍스트는 총 네 종류인 것이다

### 23.2 소스코드 평가와 실행

- 모든 소스코드는 실행에 앞서 평가 과정을 거친다
- 소스코드 평가 과정에서는..
    - 실행 컨텍스트 생성
    - 선언문 실행 → 실행 컨텍스트가 관리하는 스코프에 등록
- 소스코드 평가 후 선언문을 제외한 소스코드가 순차적으로 실행됨
    - 즉, 런타임이 실행됨
    - 런타임에서는 소스코드 실행에 필요한 정보들(e.g. 식별자의 참조)을 실행 컨텍스트의 스코프에서 검색하여 취득한다!
    - 변수 값 변경 등, 소스코드의 실행 결과는 실행 컨텍스트의 스코프에 등록됨

### 23.3 실행 컨텍스트의 역할

1. 전역 코드 평가
    - 선언문만 먼저 실행하여 전역 변수와 전역 함수를 실행 컨텍스트가 관리하는 전역 스코프에 등록
    - `var` 가 전역 객체의 프로퍼티가 되는 것도 이 단계에서 수행된다고 한다
    - 생각 이상으로 더 쓰지 말아야겠다
2. 전역 코드 실행
    - 런타임
    - 전역 변수에 값이 할당되고 함수가 호출됨
3. 함수 코드 평가
    - 함수가 호출되어 코드 실행 순서가 변경된다면 함수 내부 문들을 실행하기 전 함수 코드 평가 과정을 거침
    - 매개변수와 지역 변수 선언문의 평가 과정이 수행되며 지역 스코프에 등록됨
    - `arguments` 객체가 생성
    - `this` 바인딩 결정
4. 함수 코드 실행
    - 런타임
    - 매개변수와 지역 변수에 값이 할당됨
    - 함수 내부 문들이 수행될 때 스코프 체인을 통해 검색
5. 함수 코드 실행이 종료된다면 다시 2단계로 돌아가 코드를 실행함
- 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요함
    - 선언에 의해 생성된 식별자를 스코프를 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야함
    - 스코프 체인을 형성해야함
    - 함수 호출 등의 이유로 코드 실행 순서가 변경될 수 있어야 하고, 다시 되돌아갈 수 있어야함
- 실행 컨텍스트는 식별자를 등록하고 관리하는 `스코프` 와 코드 실행 순서 관리를 구현한 내부 메커니즘
- 모든 자바스크립트 코드는 실행 컨텍스트를 통해 실행되고 관리됨
- 식별자와 스코프는 실행 컨텍스트의 `렉시컬 환경` 으로 관리
- 코드 실행 순서는 `실행 컨텍스트 스택` 으로 관리

### 23.4 실행 컨텍스트 스택

- 실행 컨텍스트는 `스택` 으로 관리되며, 이를 `실행 컨텍스트 스택` 이라고 함
    - 이를 `콜스택` 이라고 표현하기도 함
- 즉, 전역 실행 컨텍스트가 스택의 가장 아래에 존재하고, 필요에 따라 추가되는 실행 컨텍스트들이 `push` 되는 구조
- 소스코드가 평가되는 시점에 실행 컨텍스트가 생성되며 콜스택에 push 되고, 코드 실행이 전부 끝난다면 콜스택에서 해당 실행 컨텍스트를 `pop` 하는 사이클
- 스택 구조를 가지기 때문에 최상위에 있는 실행 컨텍스트가 현재 실행 중인 실행 컨텍스트인 것이다

### 23.5 렉시컬 환경

- 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조
- 실행 컨텍스트를 구성하는 컴포넌트 중 하나
- 콜스택이 코드 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리함
    - 즉, 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소인… 렉스컬 스코프의 실체이다

### 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

1. 전역 객체 생성
    - 전역 객체는 전역 코드가 평가되기 전에 생성됨
    - 즉, 전역 객체 생성 → 전역 코드 평가 → 전역 실행 컨텍스트 생성 → 전역 렉시컬 환경 생성 .. 의 순서
        - 전역 객체가 생성되는 시점에서 표준 빌트인 객체를 추가하거나 호스트 객체를 추가함
    - 전역 객체도 `Object.prototype` 을 상속받는다고 한다 😱
        - 전역 객체도 프로토타입 체인의 일원이라고 한다…….
        - 태초에 `Object.prototype` 이 있었다..
2. 전역 코드 평가
    - 소스코드가 로드되면 다음과 같은 순서로 진행
    1. 전역 실행 컨텍스트 생성
        - 빈 전역 실행 컨텍스트를 생성하여 콜스택에 push
    2. 전역 렉시컬 환경 생성
        1. 전역 환경 레코드 생성
            - 전역 환경 레코드는 전역 변수를 관리하는 `전역 스코프`, `전역 프로퍼티` 와 `빌트인 전역 함수`, `표준 빌트인 객체` 를 제공
            - var 로 선언한 변수는 이 시점 즈음에 정의됨
            - `let`, `const` 의 블록 레벨 스코프를 지원하기 위해 ES6 부터 전역 환경 레코드는 `객체 환경 레코드` 와 `선언적 환경 레코드` 로 구성
            1. 객체 환경 레코드 생성
                - `var` 가 관리되는 영역
                    - `var` 는 `undefined` 로 정의됨
                - 함수 선언문으로 정의된 전역 함수도 관리됨
                    - 이 시점에서 함수의 식별자가 생성되며, 함수 식별자와 함수 객체를 즉시 바인딩
                    - 이로 인해 함수 선언문으로 정의한 함수는 함수 선언문이 실제로 실행되기 이전에 호출할 수 있는 것
                - `전역 객체 생성` 단계에서 생성된 `BindingObject` 라는 객체를 통해 전역 객체 프로퍼티/메서드를 추가함
                    - `BindingObject` 는 객체 환경 레코드와 연결 되어 있음!
            2. 선언적 환경 레코드 생성
                - `let`, `const` 로 선언한 변수는 이 쪽에서 관리됨
                - `var` 와는 달리, 선언과 초기화가 나뉘어 진행되기 때문에 `일시적 사각 지대`.. 라는 것에 빠질 수 있다
                    - 실제로 초기화가 되기 전 까지 참조할 수 없는 시간이 존재
                    - 오히려.. 안정적인걸..
        2. `this` 바인딩
            - `[[GlobalThisValue]]` 라는 내부 슬롯에 `this` 가 바인딩됨
        3. 외부 렉시컬 환경에 대한 참조 결정
            - 전역 렉시컬 환경(전역 렉시컬 스코프)는 스코프 체인의 종점에 존재
                - 그렇기 때문에 전역 렉시컬 환경에 연결된 외부 렉시컬 환경에 대한 참조는 null
    3. 전역 코드 실행
        - 변수 할당문이나 함수 호출문을 실행하기 위해서는 해당 식별자가 이미 선언 되어있는 식별자인지 확인해야 하는데..
            - 스코프마다 같은 이름의 식별자를 선언할 수 있으므로 해당 식별자가 어떤 스코프의 식별자를 참조해야할지 결정해야함
            - 이를 `식별자 결졍(Identifier Resolution)` 이라고함
            - 식별자 결정을 위해 식별자를 검색하는 과정은 실행 중인 실행 컨텍스트에서 수행됨
            - 만약, 실행 중인 실행 컨텍스트에 선언된 식별자가 없다면 해당 실행 컨텍스트의 렉시컬 환경에 연결된 외부 렉시컬 환경에서 탐색함
            - 이 것이 스코프 체인 탐색의 원리임
    4. foo 함수 코드 평가
        - 함수가 호출되면 함수 코드 평가 과정이 실행됨
        1. 함수 실행 컨텍스트 생성
            - 이 때 생성된 함수 실행 컨텍스트는 실행 컨텍스트 스택에 `push` 됨
        2. 함수 렉시컬 환경 생성
            1. 함수 환경 레코드 생성
                - arguments 객체, 매개변수, 함수 내부에서 선언된 지역 변수, 중첩 함수 등등을 등록하고 관리함
            2. this 바인딩
                - 함수 호출 방식에 따라 `[[ThisValue]]` 에 `this` 가 바인딩됨
        3. 외부 렉시컬 환경에 대한 참조 결정
            - 함수의 상위 스코프는 `[[Environment]]` 내부 슬롯에 저장됨
                - 함수가 정의된 위치에 따라 상위 스코프가 결정됨
                - 렉시컬 스코프
    5. foo 함수 코드 실행
        - 이 단계에서도 식별자 결정을 위한 스코프 체인 검색이 실행됨
    6. bar 함수 코드 평가
        - 이후, 함수가 호출될 때 마다 4. foo 함수 코드 평가 단계처럼, 함수 코드 평가 과정이 수행됨
    7. bar 함수 코드 실행
        - bar 함수 내부에 `console.log()` 가 존재한다면..
        1. `console.log()` 를 수행하기 위해서는 스코프 체인 검색을 계속 해나가다 전역 렉시컬 환경까지 올라가게 됨
        2. `console` 식별자는 전역 환경 레코드의 객체 환경 레코드의 `BindingObject` 를 통해 전역 객체에서 찾을 수 있음
            - 즉, `console` 은 전역 객체의 프로퍼티이당
        3. `console` 프로퍼티를 찾았다면, 프로토타입 체인 검색을 통해 `.log()` 를 찾음
    8. bar 함수 코드 실행 종료
        - 더 이상 실행할 코드가 없다면 실행 단계가 종료됨
        - 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 `pop` 되며, 그 이전에 생성된 실행 컨텍스트가 현재 실행 중인 실행 컨텍스트가 됨
        - 다만, 실행 컨텍스트가 `pop` 되었다고 해서, bar 의 함수 렉시컬 환경까지는 사라지는 것이 아님
            - bar 함수 렉시컬 환경을 참조하고 있는 객체가 있을 수 있기 때문
            - 더 이상 참조하는 곳이 없어진다면 가비지 컬렉터가 수거해감
    9. foo 함수 코드 실행 종료
    10. 전역 코드 실행 종료
    
    ### 23.7 실행 컨텍스트와 블록 레벨 스코프
    
    - 블록문이 실행되면 블록 레벨 스코프를 생성하게 된다
        - 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성
        - 새롭게 생성된 블록 렉시컬 환경은 블록문을 실행한 구문의 렉시컬 환경과 교체됨
            - e.g. 함수 foo() 에서 if 문이 호출되었다면, foo() 의 렉시컬 환경 정보는 if 문의 렉시컬 환경과 교체됨
            - e.g. if 블록 렉시컬 환경이 참조하는 외부 참조 렉시컬 환경은 foo() 의 렉시컬 환경이 되어 스코프 체인이 형성