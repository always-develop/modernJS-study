# 클로저

- 함수형 프로그래밍 언어에서 사용되는 중요한 특성이며 자바스크립트 고유의 개념은 아니다.

> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.
From. MDN
> 

## 24.1 렉시컬 스코프

- 함수가 어디서 호출되었는지가 중요하지 않고, 함수가 어디에서 정의되었는지에 따라 상위 스코프를 결정한다.
    - 이것이 렉시컬 스코프이다.
- 스코프의 실체는 **실행 컨텍스트의 렉시컬 환경**이고,
- 렉시컬 환경은 자신의 **외부 렉시컬 환경에 대한 참조**를 통해 상위 렉시컬 환경과 연결되고,
- 이것은 스코프 체인이며
- **외부 렉시컬 환경에 대한 참조**는 함수가 정의된 위치에 의해 결정된다.

## 24.2 함수 객체의 내부 슬롯 `[[Environment]]`

- 함수가 정의되어 평가되는 시점에서 상위 스코프를 기억해야한다.
    - 이것이 내부 슬롯 `[[Environment]]`에 상위 스코프의 참조를 저장한다.
- 평가되는 시점이란, 함수가 호출되는 시점이 아닌 해당 함수가 정의된 스코프의 코드가 평가되는 시점에 함수의 객체가 생성되어 내부 슬롯인 `[[Environment]]`에 평가되고 있는 스코프가 저장된다.

## 24.3 클로저와 렉시컬 환경

```jsx
const x = 1;

function outer() {
	const x = 10;
  // inner 함수의 외부 렉시컬 환경에 대한 참조는 outer 함수 스코프이다.
	const inner = function () { console.log(x); };
	return inner;
}

const innerFunc = outer();
// inner 함수를 반환하며 생명주기 끝났으며
// 이 함수가 가지고 있던 지역변수 x는 유효하지 않게 되었다.
// = outer 함수의 실행 컨텍스트가 pop되어 사라졌다는 뜻이다.
innerFunc(); // 10 outer 함수의 실행컨텍스트는 pop되어 없는데 지역 변수 x의 값이 나타나고 있다.
```

- 즉, 위의 현상은 참조하고 있는 외부 함수의 실행 컨텍스트가 사라졌는데도 불구하고, 중첩 함수가 더 오래 살아있어 외부 렉시컬 환경의 변수를 참조를 하고 있는 상황인거다.
    - 이런 중첩 함수를 클로저라고 부른다.
- 실행 컨텍스트에서 pop되어 스택에서 제거되었다 한들, 해당 함수의 렉시컬 환경까지 소멸하는 것은 아니기 때문에 참조는 가능하다.
    - 왜냐면 inner함수의 내부 슬롯인 [[Environment]]에 외부 렉시컬 환경에 대한 참조에 이미 outer 함수의 렉시컬 환경이 할당되어 있기 때문이다.
    - 이런 경우, 가비지 컬렉터는 누군가 참조하고 있는 렉시컬 환경에 대한 메모리 공간을 해제하지 않는다.