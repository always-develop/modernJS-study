# 1차원 배열

## 배열?

- 같은 타입의 변수들로 이루어진 유한 집합
    - 처음에 선언한 만큼의 길이만 사용할 수 있다.
    - resize되지 않는다. → resize가 가능한 건 동적 배열
- index는 0부터 시작하는 양의 정수만을 가질 수 있다.

```c
// 배열 선언 문법
{type} arrayName[arrayLength];
```

- 사용법

```c
int main() {
	int numberArray[3]; // 길이가 3인 int형 배열 선언
	
	numberArray[0] = 1; // 배열의 0번째에 1 할당
	numberArray[1] = 2; // 배열의 1번째에 2 할당
	
	printf("numberArray %d", numberArray[1]); // numberArray 2
	printf("numberArray %d", numberArray[2]); // numberArray 0
}
```

- 배열을 선언하고 초기화하는 방법
    - element의 개수에 맞게 배열의 길이가 설정된다.

```c
{type} arrayName[] = {element1, element2 ...};
```

## 배열이 차지하는 메모리 크기

- 배열의 길이 x sizeof(type)
    - 배열을 이루는 타입의 메모리 크기와 길이에 비례한다.

# 선형 자료 구조

## 18.2 동적 배열

- 배열을 이용해 만들어낸 별도의 자료 구조이기 때문에 **배열의 특징**을 그대로 받는다.
    - 원소들은 메모리의 연속된 위치에 저장된다.
        - 캐시의 효율성과 직결되어 중요한 포인트
    - 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.

> **O(1)?**
- 시간복잡도 개념에서 상수를 의미한다.
- 입력에 관계없이 복잡도가 동일하게 유지된다.
> 
- **동적 배열만의 특징**은 아래와 같다.
    - 배열의 크기를 변경하는 `resize()` 연산이 가능하다.
        - 이 동작을 수행하는 데는 배열의 크기 N에 비례하는 시간이 걸린다.
    - 주어진 원소의 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 `append()` 연산을 지원한다.
        - 이 동작을 수행하는 데는 상수 시간이 걸린다.
- 동적 배열의 크기가 바뀌는 과정은 아래와 같다.
    - 새 배열을 동적으로 할당 받는다.
    - 기존 원소들을 복사한다.
    - 새 배열을 참조하도록 바꿔치기 한다.
- 동적 배열의 내부에서는 배열의 크기가 커지는 것에 대한 여유분의 메모리를 확보하고 있고, 실제로 동적 배열을 사용하는 프로그램에서는 실제 사용 중인 배열의 크기만 인식한다.
    - 그렇기 때문에 현재 배열의 크기와 배열이 현재 저장된 메모리 내의 위치 외에 용량을 저장해야한다

![동적 배열 A](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c05c3e73-b74c-447e-8a88-4fb2a26e7f5c/Untitled.png)

동적 배열 A

- A 같은 경우엔 `append()` 연산으로 size만 1 늘리면 된다.

![동적 배열 B](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e616e6f1-40e6-4778-bd41-ab5af1ce77a6/Untitled.png)

동적 배열 B

- B 의 경우처럼 더 늘릴 크기가 없다면? → **재할당 과정**
    - 더 큰 새 배열을 동적으로 할당 받는다.
    - 새 배열에 기존 배열의 내용을 모두 복사한다.
    - 복사한 다음 배열에 대한 포인터를 바꿔치기 한다.
- 동적 배열은 직접 구현할 일이 거의 없다.

## 18.3 연결 리스트

- 특정 위치에서 삽입과 삭제를 상수 시간에 할 수 있게 해준다.
- 배열은 메모리의 연속된 위치에 원소들이 저장되어 있지만 연결 리스트는 원소들이 흩어져 있고, 각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고 있다.
    - 양방향 연결 리스트

> **양방향 연결 리스트**
- 각 원소가 이전과 다음 원소에 대한 정보를 모두 가지고 있다.
**단방향 연결 리스트**
- 각 원소가 다음 원소를 가리키는 포인터만 가지고 있다.
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8e0e156-a372-4449-aace-5d9a764fa261/Untitled.png)

- 노드들이 흩어져 있기 때문에 특정 위치의 값을 찾는 것은 쉽지 않다.
- 반면 순서를 유지하며 노드를 추가하거나 삭제하는 것은 간단하다.
    - 다른 노드들은 유지한 채, 삽입 또는 삭제할 노드와 이전과 이후 포인터만 변경한다.

## 18.4 동적 배열과 연결 리스트의 비교

- 이 둘은 삽입과 삭제, 임의의 원소에 접근하는데 드는 시간이 다르다.
- 삽입과 삭제할 일이 없거나, 배열의 끝에서만 삽입과 삭제가 일어난다면 거의 **동적 배열**이 좋다.
    - 임의의 원소에 빠르게 접근이 가능하며 원소들이 메모리에 연속하여 배치하고 있기 때문에 CPU 캐시 효율도 높다.
- 임의의 원소를 접근하는 것이 아닌, 모든 원소들을 순회하며 삽입과 삭제를 하면 **연결 리스트**가 좋다.


# 큐와 스택, 데크

### 큐와 스택, 데크

- 일렬로 늘어선 같은 형태의 자료들을 저장한다.
- 셋의 차이는 어느 쪽 끝에서 자료를 넣고 뺄 수 있는가 이다.
- 셋 다 O(1)에 이루어진다.
- `push` : 자료를 넣는 것
- `pop` : 자료를 빼는 것

### 큐

- 선입선출
- 가장 먼저 들어간 자료 순으로 빠진다.
- 줄서기

### 스택

- 후입선출
- 가장 늦게 들어간 것 순으로 빠진다.
- 컨텍스트 관리

### 데크

- 양쪽 끝에서 자료들을 넣고 뺄 수 있다.
- 스택과 큐를 모두 구현 가능하다.

## 19.2 큐와 스택, 데크의 구현

- 연결 리스트
    - 양쪽 끝에서 추가와 삭제를 모두 상수 시간에 할 수 있다.
    - 노드의 할당과 삭제, 포인터를 따라가는데 드는 시간이 걸리기 때문에 가장 효율적이진 않다.
- 동적 배열
    - 스택은 쉽게 가능하다.
    - 하지만 앞에서 추가와 삭제가 일어나는 것은 동적 배열에서 쉽지 않다.
- 대부분 표준 라이브러리에서 지원한다.

# 트리의 구현과 순회

## 21.1 도입

- 계층적 구조의 자료 구조

![상위-하위 개념으로 연결된 트리 구조](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3866b8c6-05aa-4997-aefa-fc66de347454/Untitled.png)

상위-하위 개념으로 연결된 트리 구조

![특별한 규칙을 가진 트리 구조](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e586ad02-49da-43d9-9125-bfa4fc6859aa/Untitled.png)

특별한 규칙을 가진 트리 구조

- 연결된 두 노드 중 상위에 있는 것이 `부모` 노드 , 하위는 `자식` 노드
- 부모 노드가 같은 두 노드는 `형제` 노드
- 부모 노드와 그의 부모들을 통틀어 `선조` 노드
- 자식 노드와 그의 자식들을 통틀어 `자손` 노드
- 모든 노드의 선조이고, 부모이면 `뿌리 노드` , `루트(root)`
- 자식이 하나도 없는 노드는 `잎 노드` , `리프(leaf)`

### 트리와 노드 속성

- `깊이` : 루트에서 어떤 노드까지 도달하기 위해 거쳐야하는 간선의 수
- `높이` : 트리에서 가장 깊숙히 있는 노드의 깊이

### 트리의 재귀적 속성

- 가장 유용하게 쓰이는 이유는 `재귀적 속성`때문이다.
- [상위-하위 개념으로 연결된 트리 구조] 에서 ‘탐색형 자료구조(=t)’에서 그 자손들로 구성된 트리를 `‘t’를 루트로 하는 서브트리` 라고 한다.
- 모든 트리는 루트와 루트 밑에 있는 서브 트리라고 얘기할 수 있다.

### 트리의 표현

- 각 노드를 하나의 구조체나 객체로 표현하고, 이들을 서로의 포인터로 연결하는 것
- 각 노드들은 자신의 부모와 모든 자손들에 대한 포인터를 가지고 있다.

## 21.2 트리의 순회

- 자료를 전부 순회하는 것에서 트리의 재귀적 속성을 이용한다.
- 트리가 루트가 주어질 때 루트를 방문하여 각 서브트리로 재귀적으로 방문하는 함수를 만들어 트리의 모든 노드를 순회할 수 있다.
- O(n)시간 걸린다.

# 이진 검색 트리

## 22.1 도입

- 일정한 순서에 따라 정렬한 상태로 저장해준 검색 트리
    - 32비트 정수들을 작은 것부터 큰 것까지 정렬한 상태로 저장할 수도 있고, 문자열을 가나다순으로 정렬해서 저장할 수도 있다.
- 원소의 추가와 삭제만이 아니라 특정 원소의 존재 여부 확인 등을 할 수 있다.
- 대부분 표준 라이브러리에서 제공한다.

## 22.2 이진 검색 트리의 정의와 조작

- 이진 트리?
    - 각 노드가 왼쪽과 오른쪽, 최대 두 개의 자식 노드만을 가질 수 있는 트리
    - 자식 노드의 배열 대신 두 개의 포인터 left와 right를 담는 객체로 구현된다.

![이진 트리의 옳은 예](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2c26d751-7373-4ba2-ba93-cd335c674687/Untitled.png)

이진 트리의 옳은 예

![이진 트리의 잘못된 예](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2f317ba1-30e6-4b53-bb17-701a96a2cf92/Untitled.png)

이진 트리의 잘못된 예

- 위의 트리는 왼쪽은 루트보다 작은 값, 오른쪽은 루트보다 큰 값으로 이뤄진 트리이다.
    - 그러나 잘못된 예처럼 루트인 16보다 작은 원소인 15가 루트보다 작은 값으로 올 수는 없다.

### 순회

- 크기 순서로 정렬된 원소의 목록을 얻을 수 있다.
- 현재 노드보다 작은 원소들은 모두 왼쪽 서브트리에 있고, 현재 노드보다 큰 원소들은 모두 오른쪽 서브트리에 있다.

### 자료의 검색

- 루트인 16만 봐도 15를 트리의 어느 쪽에서 찾아봐야 하는지 알 수 있다.

### 조작

- 이진 검색 트리의 진가는 집합에 원소를 추가하거나 삭제하는 조작 연산을 할 때이다.
- 선형 구조가 아니기 때문에 새 원소가 들어갈 자리를 찾고 노드를 추가하기만 하면 된다.
    - 트리 구조를 해치지 않는다. 새 잎이 추가 되는 현상만 있을 뿐이다.
- 삭제는 오히려 어렵다.
    - `합치기` 연산으로 구현한다.
    - 삭제할 노드의 서브 트리를 합치고, 삭제할 노드의 루트를 새 루트로 교체한다.

# 우선순위 큐와 힙

## 23.1 도입

- 우선순위 큐
    - 선입선출이 아니고, 우선순위가 가장 높은 자료가 가장 먼저 꺼내진다.
    - 연결 리스트나 동적 배열로 구현 가능하다 O(n) 시간 소요되며 비효율적이다.
    - 힙을 통해 구현하는 것이 가장 적합하다.
- 힙
    - 가장 큰 또는 가장 작은 원소를 찾는데 최적화된 형태의 이진 트리
    - O(lgN) 시간 소요

## 23.2 힙의 정의와 구현

- 특정한 규칙을 만족하는 이진 트리
- `대소 관계 규칙`: 부모 노드가 가진 원소는 항상 자식 노드가 가진 원소 이상이다.
- 힙의 모양 규칙
    - 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차 있어야 한다.
    - 마지막 레벨에 노드가 있을 때는 항상 왼쪽부터 순서대로 채워져 있어야 한다.

### 배열을 이용한 힙의 구현

- 트리에 포함된 노드의 개수만 알면 트리 전체의 구조를 알 수 있다.

![배열을 이용한 힙](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de20caf2-aef7-4b9b-a487-ea83f962d920/Untitled.png)

배열을 이용한 힙

- 배열을 제일 위 왼쪽 끝부터 채웠다.
- 부모 노드의 왼쪽 노드는 배열의 홀수 index, 오른쪽 노드는 배열의 짝수 index인 규칙을 가지고 있다.

### 새 원소의 삽입

- 모양 규칙에 의해 새 노드는 항상 `heap[]` 의 맨 끝에 추가된다.
- 그리고 새 노드는 트리의 제일 밑 왼쪽부터 자신의 자리를 찾아간다.

### 최대 원소 꺼내기

- 힙의 모양 구조에 의하면 힙의 마지막에 있는 노드는 지우고 시작한다.
    - 리프 노드
- 마지막에 있는 원소는 루트에 덮어씌운다.
    - 부모-자식 간의 대소 관계만 취급하기 때문에 규칙을 어기는 것은 아니다.
    - 기존 루트의 자식인 원소 중 더 큰 원소를 선택해 루트가 갖고 있는 원소와 맞바꾸는 작업을 트리의 바닥에 도달하거나, 두 자손이 모두 자기 자신 이하의 원소를 갖고 있을 때 까지 반복한다.

# 해시테이블

## 해시 테이블?

- 특정 값을 해시 함수에 통과시켜 나온 인덱스에 저장하는 자료 구조

### 직접 주소 테이블

- `value`가 곧 `key`다.
- value와 key가 동일하여 값에 쉽게 접근할 수 있다.
- 삽입, 수정, 삭제하는 것 또한 어디에 있는지만 알면 쉽게 해결할 수 있다.
- 시간 복잡도는 O(1)이다.
- 공간의 효율성이 좋지 못하다.
    - 중간 중간 empty한 공간이 굉장히 많다.

```jsx
class DirectAddressTable {
  constructor () {
    this.table = [];
  }

  setValue (value = -1) {
    this.table[value] = value;
  }

  getValue (value = -1) {
    return this.table[value];
  }

  getTable () {
    return this.table;
  }
}

const myTable = new DirectAddressTable();
myTable.setValue(3);
myTable.setValue(10);
myTable.setValue(90);

console.log(myTable.getTable()); 

// [empty × 3, 3, empty × 6, 10, empty × 79, 90]
```

### 해시 함수로 보완

- `해시 함수`는 임의의 길이를 가지는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다.
- 이때 함수가 뱉어 내는 결과물을 `해시`라고 부른다.

### 해시의 충돌

- 다른 값을 해시 함수에 넣었는데 같은 값이 튀어나오는 현상
- 해시 함수가 얼마나 균일하게 값을 퍼트릴 수 있는지가 가장 중요하다.
- 완전한 충돌을 방지하는 것은 힘들며 충돌을 감안하되 최소화하기 위해 해시 함수의 알고리즘을 개발하거나, 충돌이 생겼을 때 우회하는 방법을 사용해야한다.